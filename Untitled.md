## **AI 交易系统之多代理协作平台 (MCP) 技术实现方案 (V2 \- 包含动态监控)**

本方案旨在设计一个由多个独立、协作的 AI 代理组成的自动化交易系统。系统遵循微服务思想，代理之间通过消息队列进行异步通信，实现高内聚、低耦合的健壮架构。此版本已集成**动态持仓监控**机制。

### **一、 系统核心架构**

我们将系统设计为事件驱动型架构。各个代理作为独立的服务运行，它们不直接调用彼此，而是通过一个中心的**消息队列 (Message Queue)** 来发布和订阅消息，进行协作。

**架构图:**

\[用户/定时任务\] \-\> \[API 网关\] \-\> \[消息队列\]  
                                    |  
      \+-----------------------------+-----------------------------+  
      | (订阅/发布)                 | (订阅/发布)                 |  
\[分析代理\] \<-----\> \[数据库\] \<-----\> \[复盘代理\]  
      ^ | (发布 trade\_proposal)       ^ (读取 trade\_log)  
      | v (写入/读取)                 | (写入 learning\_summary)  
      | \[风控代理\]                      |  
      |   | (发布 approved\_order)     |  
      |   v                           |  
\[触发\] \[执行代理\] \---------------------+ (写入 trade\_log)  
      |   | (注册 triggers)  
      |   v  
      | \[监控代理 (纯代码)\] \<--- \[实时数据流\]  
      |   (高频检查)  
      \+----------------------------- \[交易所 API\]

**核心组件:**

1. **API 网关 (API Gateway):** 系统的统一入口，负责接收外部请求（如用户手动触发分析、定时任务），进行验证，并将任务发布到消息队列。  
2. **消息队列 (Message Queue):** 整个系统的通信中枢（例如 RabbitMQ, Redis Pub/Sub）。代理之间通过它传递 JSON 格式的消息，实现解耦和异步处理。  
3. **数据库 (Database):** 系统的持久化存储中心。  
   * **交易日志库 (Trade Log):** 记录所有交易的完整生命周期，供复盘代理学习。  
   * **配置库 (Config):** 存储系统配置、风控规则、API 密钥等。  
   * **状态库 (State):** 存储当前的账户状态、持仓信息等。  
   * **高速缓存 (Cache \- 如 Redis):** 用于监控代理存储和管理所有激活的监控触发器状态。

### **二、 代理职责与工作流详解**

#### **1\. 分析代理 (Analysis Agent)**

* **职责:** 市场的“大脑”，负责生成交易观点和持仓管理计划。  
* **触发方式:**  
  1. 订阅 analysis\_request 消息（用于**开仓决策**）。  
  2. 订阅 re\_analysis\_trigger 消息（用于**持仓管理**）。  
* **工作流:**  
  1. 收到触发消息。  
  2. 从数据库读取最新的\*\*“近期学习总结”\*\*。  
  3. **启动分析会话:** 向 LLM 发送初始指令，告知其任务目标（是开仓分析还是持仓复盘）、可用的工具（如 get\_kline\_data(timeframe)）以及所有相关上下文。  
  4. **进入工具调用循环 (Tool-Use Loop):** LLM 主动调用工具，获取它认为完成当前任务所需的所有数据。  
  5. **生成最终策略:**  
     * **对于开仓:** 返回包含 strategy\_details 和 monitoring\_triggers（监控触发器）的结构化 JSON。  
     * **对于持仓管理:** 返回下一步操作（如平仓、调整止损或继续持有），如果继续持有，则可以提供一套**新的** monitoring\_triggers。  
  6. 将策略封装成 trade\_proposal 消息，发布到消息队列。

#### **2\. 风控代理 (Risk Agent)**

* **职责:** 系统的“刹车”，对所有**即将执行的动作**进行最终的风险审查。  
* **触发方式:** 订阅 trade\_proposal 消息。  
* **工作流:**  
  1. 收到 trade\_proposal 消息（无论是开仓还是持仓调整）。  
  2. 加载配置文件中的静态风控规则。  
  3. 获取动态账户状态。  
  4. **执行检查:** 对提议的动作（如开仓大小、杠杆、新的止损点）进行严格的数值检查。  
  5. **决策:** 通过则生成 approved\_order 消息；拒绝则记录原因。

#### **3\. 执行代理 (Execution Agent)**

* **职责:** 系统的“双手”，负责与交易所进行实际交互。  
* **触发方式:** 订阅 approved\_order 消息。  
* **工作流:**  
  1. 收到 approved\_order 消息。  
  2. 解析订单参数并调用交易所 API 执行。  
  3. **关键步骤:** 交易动作（如开仓、调整止损）成功执行后：  
     * 将所有执行细节写入**交易日志数据库**。  
     * 如果该指令包含 monitoring\_triggers，则立即向消息队列发布 register\_triggers 消息，将这些触发器注册到监控代理。

#### **4\. 监控代理 (Monitoring Agent) \- (纯代码，无AI)**

* **职责:** 系统的“哨兵”，忠实地执行 AI 定义的监控任务。  
* **触发方式:**  
  1. 订阅 register\_triggers 消息来接收新的监控任务。  
  2. 订阅**高频的实时市场数据流**来进行检查。  
* **工作流:**  
  1. 收到 register\_triggers 消息后，将监控规则（触发器）及其关联的仓位信息存入高速缓存（Redis）。  
  2. 持续接收实时数据，遍历所有激活的触发器。  
  3. **由系统代码进行高频计算**，检查触发条件是否满足。  
  4. 一旦条件满足，立即向消息队列发布 re\_analysis\_trigger 消息，并包含被触发的仓位和原因。  
  5. 将该触发器从监控列表中移除（一次性触发）。

#### **5\. 复盘代理 (Review Agent)**

* **职责:** 系统的“记忆和反思中枢”，负责从历史中学习。  
* **触发方式:** 由定时任务触发（例如，每天执行一次）。  
* **工作流:**  
  1. 被定时任务唤醒。  
  2. 从**交易日志数据库**中查询已完成的交易。  
  3. 进行聚合分析，提取成功和失败的模式。  
  4. 调用 LLM 将分析结果提炼成简短的\*\*“近期学习总结”\*\*。  
  5. 将总结文本更新到数据库，供分析代理在下一次决策时使用。

### **三、 推荐技术栈**

* **编程语言:** **Python**  
* **代理框架:** **FastAPI**, **Celery**  
* **消息队列:** **RabbitMQ**  
* **数据库:** **PostgreSQL** (主数据库), **Redis** (用于监控代理的状态缓存)  
* **容器化:** **Docker & Docker Compose**