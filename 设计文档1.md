# **AI分析代理 (Analysis Agent) 技术方案文档**

版本: 2.1 (集成顺序思维)  
作者: \[您的名字/团队\]  
日期: 2025-09-18

## **1\. 概述与目标**

### **1.1 项目目标**

本项目旨在设计并实现一个高级AI分析代理，作为自动化合约交易系统的核心决策引擎。其主要目标是克服传统“黑盒式”AI模型的局限，构建一个**透明、可控、且完全由真实数据驱动**的智能分析系统。

### **1.2 核心特性**

* **决策透明性**: AI的每一个分析步骤和思考过程都将被记录和展示。  
* **行为可控性**: AI的行为将由一个外部的、确定性的程序（工作流编排器）进行严格管理。  
* **数据真实性**: AI所需的所有市场信息都必须通过调用本地的、受控的数据接口（MCP工具）来获取。  
* **分层规划能力**: AI能够识别任务复杂度，通过**递归调用**将复杂的宏观任务分解为具体的子任务来解决。  
* **结构化思考能力 (新增)**: 在处理复杂子任务时，AI将使用sequentialthinking工具来构建一个**动态、可修正、可分支**的结构化思维链，使其分析过程更加强大和透明。

## **2\. 核心架构：递归式“指挥官-执行官”模式**

本方案采用递归式的“指挥官-执行官”模式。

* **工作流编排器 (Orchestrator)**:  
  * **角色**: “指挥官” 与 “执行官” 的统一体。  
  * **实现**: 一个核心的Python类 (AIOrchestrator)。  
  * **核心职责**:  
    * **会话管理**: 其核心逻辑被封装为run\_session方法，能够启动一个独立的AI分析会话。  
    * **工具映射与执行**: 维护工具映射表，执行AI请求的本地工具。  
    * **递归调用**: 能够调用特殊的“元工具”，创建一个新的AIOrchestrator实例来处理子任务。  
* **AI代理 (Agent)**:  
  * **角色**: “智能规划师”与“深度分析师”。  
  * **核心职责**:  
    * **顶层规划 (指挥官模式)**: 制定分层的分析计划，对于复杂任务，调用decompose\_and\_execute\_task元工具进行“委派”。  
    * **子任务执行 (分析师模式)**: 在被委派的子会话中，**主要通过反复调用 sequentialthinking 工具**来构建一个详细、动态的思维链，并结合调用简单工具来完成具体任务。

## **3\. 核心配置文件**

AI代理的行为由两个外部配置文件动态定义。

* **AI的“岗位说明书” (AI\_Trading\_System\_Prompt\_V2.1.md)**:  
  * **作用**: 定义AI的角色、工作流、任务复杂度判断规则，以及**新增的关于如何在子会话中使用 sequentialthinking 工具的核心指南**。  
* **AI的“授权清单” (AI\_Trading\_System\_Tools\_V2.1.json)**:  
  * **作用**: 定义AI被授权使用的所有工具。此版本将工具明确分为三类：  
    1. **简单工具 (Simple Tools)**: 用于执行原子性操作（如get\_kline\_data）。  
    2. **元工具 (Meta-Tool)**: 如decompose\_and\_execute\_task，仅在顶层会话中使用，用于任务分解。  
    3. **思维工具 (Thinking Tool)**: 如sequentialthinking，主要在子会话中使用，用于构建和管理复杂的思考过程。

## **4\. 工作流逻辑详解（集成 sequentialthinking）**

整个分析流程由AIOrchestrator实例通过一个可递归的run\_session方法来驱动。

### **4.1 顶层会话 (指挥官模式)**

1. **接收宏观任务**: 用户或系统发出一个高阶指令（例如，“评估当前市场风险并调整BTC仓位”）。  
2. **制定主计划**: 顶层AI被调用（携带所有三类工具）。它根据“岗位说明书”，识别出这是一个复杂任务。  
3. **委派任务**: AI调用**元工具**decompose\_and\_execute\_task，并将详细的子任务目标（例如，“对BTC持仓进行全面的风险评估并制定调整方案”）作为goal参数传递。  
4. **启动子会话**: 编排器执行元工具，创建一个新的AIOrchestrator实例，并调用其run\_session方法，启动一个子会话。**关键是，传递给子会话的工具清单将只包含“简单工具”和“思维工具”**。

### **4.2 子会话 (分析师模式)**

这是sequentialthinking工具发挥核心作用的地方。

1. **接收具体任务**: 子会话AI启动，其唯一目标是完成从顶层委派下来的goal。  
2. **启动结构化思考**: 根据其“岗位说明书”的指示，子AI会做的第一件事，就是调用sequentialthinking工具来陈述它的第一个想法和初步计划。  
   * **示例调用**: sequentialthinking(thought="为了评估风险，我首先需要获取最新的持仓详情和多周期的K线数据。", nextThoughtNeeded=True, thoughtNumber=1)。  
3. **“思考-行动”循环**:  
   * **思考**: AI通过调用sequentialthinking来陈述它下一步的思考或分析。  
   * **行动**: 在思考的指引下，AI调用一个或多个**简单工具**（如get\_positions, get\_kline\_data）来获取执行思考所需的数据。  
4. **动态调整**: 在循环过程中，如果AI发现新的信息或之前的判断有误，它会再次调用sequentialthinking，但这次会使用isRevision或branchFromThought等参数来**修正或探索**其思维路径。  
5. **完成任务**: 当子AI通过这个结构化的思考过程得出最终结论时，它会最后一次调用sequentialthinking，将nextThoughtNeeded设为false，并将最终的策略总结作为thought内容。  
6. **返回总结**: sequentialthinking工具的最终输出，将作为整个子会話run\_session的返回值，被传递回顶层会话。

### **4.3 返回顶层**

顶层编排器收到子会话返回的总结报告，将其作为元工具的执行结果，追加到对话历史中，然后继续执行其主计划的下一步。

## **5\. 数据流图 (集成模式)**

\+--------------------------------+  
|      顶层 Orchestrator         |  
|      (Goal: 宏观任务)          |  
\+--------------------------------+  
     | 1\. 调用 AI (携带所有三类工具)  
     V  
\+--------------------------------+  
|           顶层 AI (指挥官)      |  
\+--------------------------------+  
     | 2\. 识别复杂任务, 调用【元工具】  
     |    decompose\_and\_execute\_task  
     V  
\+--------------------------------+  
|      顶层 Orchestrator         | \----\> 3\. 创建子级Orchestrator实例  
\+--------------------------------+       \+--------------------------------+  
                                       |      子级 Orchestrator         |  
                                       |      (Goal: 复杂子任务)        |  
                                       \+--------------------------------+  
                                            | 4\. 调用 AI (携带【简单】+【思维】工具)  
                                            V  
                                       \+--------------------------------+  
                                       |         子级 AI (分析师)        |  
                                       \+--------------------------------+  
                                            | 5\. 反复调用【思维工具】  
                                            |    sequential\_thinking  
                                            |    来构建思考链，并在此过程中  
                                            |    调用【简单工具】获取数据  
                                            V  
                                       \+--------------------------------+  
                                       |      子级 Orchestrator         |  
                                       | 6\. 返回子任务的最终总结报告      |  
                                       \+--------------------------------+  
                                            |  
                                            | 7\. 总结报告作为【元工具】的  
                                            |    执行结果，返回给顶层  
                                            V  
\+--------------------------------+  
|      顶层 Orchestrator         |  
| 8\. 将总结追加到历史, 继续主计划   |  
\+--------------------------------+  
