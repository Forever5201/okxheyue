# **AI分析代理 (Analysis Agent) 技术方案文档**

版本: 1.0  
作者: \[您的名字/团队\]  
日期: 2025-09-13

## **1\. 概述与目标**

### **1.1 项目目标**

本项目旨在设计并实现一个高级AI分析代理，作为自动化合约交易系统的核心决策引擎。其主要目标是克服传统“黑盒式”AI模型的局限，构建一个**透明、可控、且完全由真实数据驱动**的智能分析系统。

### **1.2 核心特性**

* **决策透明性**: AI的每一个分析步骤和思考过程都将被记录和展示，而非仅提供一个无法解释的最终信号。  
* **行为可控性**: AI的行为将由一个外部的、确定性的程序（工作流编排器）进行严格管理和引导，确保其始终在预设的规则框架内运行。  
* **数据真实性**: AI无法直接接触外部世界或凭空想象数据。它所需的所有市场信息都必须通过调用本地的、受控的数据接口（MCP工具）来获取。

## **2\. 核心架构：项目经理 \+ AI分析师**

本方案采用“项目经理与AI分析师”的设计模式，以实现逻辑与智能的清晰分离。

* **工作流编排器 (Orchestrator)**:  
  * **角色**: “项目经理”。  
  * **实现**: 一个核心的Python应用程序 (orchestrator\_main.py)。  
  * **职责**:  
    * 管理整个分析任务的生命周期。  
    * 加载并向AI提供行为准则（系统提示词）和能力清单（工具定义）。  
    * 作为AI与本地系统（文件、数据库等）之间唯一的通信桥梁。  
    * 调用AI模型API，并处理其返回的请求。  
    * 执行AI请求的本地工具，并将结果反馈给AI。  
* **AI代理 (Agent)**:  
  * **角色**: “AI分析师”。  
  * **实现**: 一个支持函数调用/工具使用的第三方大语言模型（例如OpenAI GPT-4o, Google Gemini）。  
  * **职责**:  
    * 在安全环境中进行思考和推理。  
    * 根据“岗位说明书”（系统提示词）制定分析计划。  
    * 通过请求调用“授权清单”中定义的工具来获取数据，以执行其计划。  
    * 基于获取的数据进行综合分析，并提交结构化的最终建议。

## **3\. 核心配置文件**

AI代理的行为由两个外部配置文件动态定义，实现了代码与配置的分离，便于迭代和维护。

* **AI的“岗位说明书” (AI\_Trading\_System\_Prompt\_V1.md)**:  
  * **格式**: Markdown 文本文件。  
  * **作用**: 定义AI的角色、最高指令、必须遵守的核心工作流、工具使用规则以及沟通风格。这是塑造AI“思维模式”的核心文件。  
* **AI的“授权清单” (AI\_Trading\_System\_Tools.json)**:  
  * **格式**: JSON 文件。  
  * **作用**: 用严格的、机器可读的格式，定义AI被授权使用的所有工具。每个工具都包含名称、功能描述和详细的参数规格（JSON Schema）。这是限制AI“行动能力”的核心文件。

## **4\. 工作流逻辑详解**

整个分析流程由“工作流编排器”通过一个三步走的模式来驱动。

### **4.1 第一步：准备工作 (Initialization)**

当一个分析任务被触发时，编排器首先执行以下准备操作：

1. **加载“岗位说明书”**: 从 AI\_Trading\_System\_Prompt\_V1.md 文件中读取全部内容，存入一个字符串变量 (system\_prompt\_text)。  
2. **加载“授权清单”**: 读取并解析 AI\_Trading\_System\_Tools.json 文件，将其内容存入一个Python对象 (tools\_definition)。  
3. **初始化对话历史**: 创建一个名为 messages 的列表，并将“岗位说明书”作为第一条system角色的消息放入，随后放入用户的初始请求（例如，“请分析BTC/USDT”）。

### **4.2 第二步：下达指令与主循环 (LLM Invocation & Main Loop)**

编排器进入一个有最大轮次限制的主循环，与AI进行多轮交互。

1. **调用AI**: 在每一轮循环中，编排器调用AI模型API，并**同时**传入当前的messages对话历史和tools\_definition工具清单。  
2. **接收并解析回复**: AI的回复可能是纯文本（例如第一步的计划陈述）或一个“工具调用请求”。  
3. **处理回复**:  
   * 如果回复是纯文本，则将其追加到messages历史中。  
   * 如果回复是“工具调用请求”，则进入第三步。

### **4.3 第三步：响应请求与调用MCP工具 (Tool Execution)**

这是连接AI的抽象请求与您本地具体实现的“翻译”层。

1. **建立映射**: 编排器内部维护一个字典，用于将“授权清单”中的抽象工具名（如 get\_historical\_data）映射到您本地的具体Python函数（如 read\_kline\_data\_from\_file）。  
2. **“翻译”与执行**: 编排器遍历AI请求的所有工具调用：  
   * 根据工具名称，从映射字典中找到对应的本地函数。  
   * 根据AI提供的参数，构建本地文件名（例如，timeframe='1h' \-\> 1h\_klines.json）。  
   * **执行您的MCP工具**：调用本地函数，从您指定的文件目录中读取数据。  
3. **反馈结果**:  
   * 本地函数返回真实的JSON数据。  
   * 编排器将这个返回结果格式化后，作为tool角色的新消息，追加到messages历史中。  
4. **循环继续**: 控制权交还给第二步，AI将在下一轮看到工具执行的结果，并决定下一步行动，直到它调用submit\_trade\_proposal为止。

## **5\. 数据流图**

\+--------------------------+  
|  工作流编排器 (您的代码) |  
\+--------------------------+  
| 1\. 加载配置文件          |  
|    \- Prompt (.md)        |  
|    \- Tools (.json)       |  
\+-----------^--------------+  
            |  
            | 2\. 调用AI API (携带Prompt和Tools)  
            v  
\+-----------+--------------+      \+------------------------------+  
|       AI大语言模型       |-----\>|   AI的思考过程 (被Prompt引导)  |  
\+--------------------------+      \+------------------------------+  
| 3\. 返回工具调用请求      |  
|    (例如: get\_historical\_data) |  
\+-----------^--------------+  
            |  
            | 4\. 接收并解析请求  
            v  
\+-----------+--------------+  
|  工作流编排器 (您的代码) |  
\+--------------------------+  
| 5\. 查找工具映射          |  
| 6\. 执行本地MCP工具       |-----\>+-----------------------------+  
|    (例如: 读取1h\_klines.json)  |   您的本地文件系统 (JSON文件)   |  
\+-----------^--------------+      \+-----------------------------+  
            | \<-----| 7\. 返回真实数据  
            |  
            | 8\. 将数据反馈给AI (回到第2步)  
            v  
\+-----------+--------------+  
|       AI大语言模型       |  
\+--------------------------+  
